import java.util.Scanner;
import java.util.Arrays;
import java.lang.Math;

public class SubprimeFibonacciSolution {
	static int PRIME = 10007;
	static int[] largestFactors = new int[PRIME];

	// generate a single subprime fibonacci sequence of length 20
	static int[] generateSubprimeFibonacci(int a, int b) {
		int[] sequence = new int[50];
		sequence[0] = a;
		sequence[1] = b;
		for(int i = 2; i < 50; i++) {
			// System.out.println("sequence[i-1] = " + sequence[i-1] + " sequence[i-2] = " + sequence[i-2]);
			sequence[i] = largestFactors[(sequence[i-1] + sequence[i-2]) % PRIME];
		}
		return sequence;
	}


	// generate a bunch of random sequences
	static void generateRandomSequences(int numSequences) {
		for(int j: generateSubprimeFibonacci(1, 2)) {
			System.out.print(j + " ");
		}
		System.out.println();
		for(int j: generateSubprimeFibonacci(2, 3)) {
			System.out.print(j + " ");
		}
		System.out.println();
		for(int j: generateSubprimeFibonacci(3, 5)) {
			System.out.print(j + " ");
		}
		for(int j: generateSubprimeFibonacci(2, 2)) {
			System.out.print(j + " ");
		}
		for(int j: generateSubprimeFibonacci(9967, 9973)) {
			System.out.print(j + " ");
		}
		for(int j: generateSubprimeFibonacci(503, 509)) {
			System.out.print(j + " ");
		}
		for(int j: generateSubprimeFibonacci(379, 9497)) {
			System.out.print(j + " ");
		}
		System.out.println();
		// for(int i = 0; i < numSequences; i++) {
			// for(int j: generateSubprimeFibonacci((int)(Math.random() * 1000), (int)(Math.random() * 1000))) {
				// System.out.print(j + " ");
			// }
			// System.out.println();
		// }
	}


	static void computeLargestFactors() {
		largestFactors[0] = 0;
		largestFactors[1] = 1;
		largestFactors[2] = 2;
		largestFactors[3] = 3;
		for (int i = 4; i < PRIME; i++) {
			for(int j = 2; j <= Math.sqrt(i); j++) {
				if(i % j == 0) {
					largestFactors[i] = i/j;
					break;
				}
			}
			if(largestFactors[i] == 0) {
				largestFactors[i] = i;
			}
		}
	}

	// recursively check if: restSequence is a subsequence of the sequence generated by a and b
	private static boolean satisfied(int a, int b, int[] restSequence) {
		if(restSequence.length == 0) {
			return true;
		}
		for(int i = 0; i < 10; i++) {
			int next = largestFactors[(a + b) % PRIME];
			if(next == restSequence[0]) {
				if(satisfied(b, next, Arrays.copyOfRange(restSequence, 1, restSequence.length))) {
					return true;
				}
			}
			a = b;
			b = next;
		}
		return false;
	}

	private static int[] solveSubprimeFibonacci(int[] sequence) {
		int[] firstFive = new int[5];
		// YOUR CODE HERE -- YOU MAY ADD HELPER METHODS IF YOU WISH ANYWHERE IN THIS FILE

		int first = sequence[0];
		int lowestSecond = 10000000;
		for(int zeroth = 0; zeroth < PRIME; zeroth++) {
			// zeroth and first define the sequence -- now just need to check if the second requirement is satisfied
			// we need to be careful about duplication
			if (satisfied(zeroth, first, Arrays.copyOfRange(sequence, 1, sequence.length))) {
				int second = largestFactors[(zeroth + first) % PRIME];
				if (second < lowestSecond) {
					lowestSecond = second;
				} 
			}	
		}

		if (lowestSecond == 10000000) {
			return null;
		}

		firstFive[0] = first;
		firstFive[1] = lowestSecond;
		firstFive[2] = largestFactors[(first + lowestSecond) % PRIME];
		firstFive[3] = largestFactors[(lowestSecond + firstFive[2]) % PRIME];
		firstFive[4] = largestFactors[(firstFive[2] + firstFive[3]) % PRIME];

		return firstFive;
	}

	public static void main(String[] args) {
		computeLargestFactors();

        // generateRandomSequences(100);

		Scanner sc = new Scanner(System.in);

		int numCases = sc.nextInt();

		for(int i = 0; i < numCases; i++) 
		{
			int lengthOfSequence = sc.nextInt();

			int [] sequence = new int[lengthOfSequence];

			for(int j = 0; j < lengthOfSequence; j++) {
				sequence[j] = sc.nextInt();
			}

			int[] firstFive = solveSubprimeFibonacci(sequence);
			if(firstFive != null) {
				System.out.print("YES: ");
				for(int j = 0; j < 5; j++) {
					System.out.print(firstFive[j] + " ");
				}
				System.out.println();
			} else {
				System.out.println("NO");
			}
		}
	}
}

